# Data Model: Backend API and Database Setup

**Feature**: Backend API and Database Setup  
**Branch**: `003-backend-api-setup`  
**Date**: January 4, 2026

## Overview

This feature introduces the foundational User entity for authentication and user management. The data model follows constitutional requirements for naming (database snake_case, TypeScript camelCase) and uses UUIDs for security and scalability.

## Entity: User

### Purpose

Represents a system user with authentication credentials. This is the core entity for user identity, required for all user-specific features including pact creation, completion tracking, and cross-device sync.

### Fields

| Field        | Database Column | Type         | Constraints                             | Purpose                        |
| ------------ | --------------- | ------------ | --------------------------------------- | ------------------------------ |
| id           | id              | UUID         | PRIMARY KEY, DEFAULT uuid_generate_v4() | Unique user identifier         |
| email        | email           | VARCHAR(255) | NOT NULL, UNIQUE                        | User's email address for login |
| passwordHash | password_hash   | VARCHAR(255) | NOT NULL                                | Bcrypt/Argon2 hashed password  |
| createdAt    | created_at      | TIMESTAMP    | NOT NULL, DEFAULT NOW()                 | Account creation timestamp     |
| updatedAt    | updated_at      | TIMESTAMP    | NOT NULL, DEFAULT NOW()                 | Last update timestamp          |

### Validation Rules

**Email**:

- MUST be valid email format (RFC 5322)
- MUST be unique across all users
- MUST be normalized to lowercase before storage
- Maximum length: 255 characters
- Required: Yes
- Example: `user@example.com`

**PasswordHash**:

- MUST be bcrypt or argon2 hashed (never store plain text)
- Minimum input password length: 8 characters (enforced before hashing)
- Maximum input password length: 72 characters (bcrypt limitation)
- Required: Yes
- Note: Validation happens on input password, not hash

**Timestamps**:

- createdAt: Auto-generated on insert, immutable
- updatedAt: Auto-updated on any field modification
- Format: ISO 8601 with timezone
- Required: Yes (handled automatically)

### Relationships

**Current**: None (this is the foundational entity)

**Future**:

- User → Pact (one-to-many): A user can have many pacts
- User → Completion (one-to-many): A user can have many completion records
- User → OAuthProvider (one-to-many): A user can link multiple OAuth providers

### Indexes

```sql
CREATE UNIQUE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_created_at ON users(created_at);
```

**Rationale**:

- Unique index on email: Enforces uniqueness at database level, speeds up login queries
- Index on created_at: Supports analytics queries for user growth tracking

### Prisma Schema

```prisma
model User {
  id           String   @id @default(uuid())
  email        String   @unique
  passwordHash String   @map("password_hash")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  @@map("users")
  @@index([createdAt], name: "idx_users_created_at")
}
```

### TypeScript Type (Generated by Prisma)

```typescript
export type User = {
  id: string;
  email: string;
  passwordHash: string;
  createdAt: Date;
  updatedAt: Date;
};
```

## State Transitions

User entity has minimal state transitions in this MVP:

```
[Non-existent] --[Registration]--> [Active]
[Active] --[Password Change]--> [Active] (updatedAt changes)
[Active] --[OAuth Link]--> [Active] (future story)
[Active] --[Account Deletion]--> [Deleted] (future story)
```

**Current Story Scope**: Only handles creation (registration). Updates and deletion deferred to future stories.

## Data Integrity Rules

### Database Level

1. **Primary Key Constraint**: Ensures every user has unique UUID
2. **Unique Constraint on Email**: Prevents duplicate accounts
3. **NOT NULL Constraints**: All fields except future optional fields must have values
4. **Foreign Key Constraints**: None in current scope, will be added with Pact entity

### Application Level

1. **Email Normalization**: Convert to lowercase before queries and inserts
2. **Password Hashing**: Never store or transmit plain text passwords
3. **UUID Generation**: Use uuid_generate_v4() at database level (PostgreSQL) or uuid library in application
4. **Timestamp Management**: Use database-level defaults, avoid manual timestamp setting

### Validation Flow

```
User Registration Request
  ↓
1. Validate email format (class-validator @IsEmail)
  ↓
2. Normalize email to lowercase
  ↓
3. Check email uniqueness (database query)
  ↓
4. Validate password strength (min 8 chars, max 72 chars)
  ↓
5. Hash password with bcrypt (cost factor 10)
  ↓
6. Create user record with Prisma
  ↓
7. Return user object (exclude passwordHash)
```

## Security Considerations

1. **Password Storage**:

   - Use bcrypt with cost factor 10 (constitutional requirement NFR7)
   - Never return passwordHash in API responses
   - Never log passwords or hashes

2. **Email Privacy**:

   - Email addresses are considered PII
   - Log only user IDs, never emails
   - Implement rate limiting on email-based queries (future)

3. **UUID vs Auto-increment**:
   - UUIDs prevent user enumeration attacks
   - No sequential patterns to exploit
   - Safe for public-facing APIs

## Query Patterns

### Common Queries

```typescript
// Find user by email (login)
const user = await prisma.user.findUnique({
  where: { email: normalizedEmail },
});

// Create new user (registration)
const newUser = await prisma.user.create({
  data: {
    email: normalizedEmail,
    passwordHash: hashedPassword,
  },
});

// Get user by ID (authenticated requests)
const user = await prisma.user.findUniqueOrThrow({
  where: { id: userId },
});

// Count total users (analytics)
const userCount = await prisma.user.count();
```

### Performance Considerations

- Email lookup: O(1) due to unique index
- ID lookup: O(1) due to primary key index
- User creation: O(1) insert operation
- Expected query volume: Low (auth queries only in this story)

## Migration Strategy

### Initial Migration

```sql
-- Migration: 20260104_init_users_table
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  email VARCHAR(255) NOT NULL UNIQUE,
  password_hash VARCHAR(255) NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE UNIQUE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_created_at ON users(created_at);
```

### Rollback Plan

```sql
DROP TABLE IF EXISTS users CASCADE;
DROP INDEX IF EXISTS idx_users_email;
DROP INDEX IF EXISTS idx_users_created_at;
```

### Future Migrations

Deferred to future stories:

- Add OAuth provider fields (Story 1.5)
- Add profile fields (username, avatar, bio) (future)
- Add soft deletion support (deletedAt timestamp) (future)
- Add email verification fields (isVerified, verificationToken) (future)

## Testing Data

### Valid Test Cases

```typescript
// Valid user 1
{
  email: "alice@example.com",
  password: "SecurePass123!"
}

// Valid user 2
{
  email: "bob@example.com",
  password: "MyPassword1"
}
```

### Invalid Test Cases

```typescript
// Invalid: Duplicate email
{
  email: "alice@example.com", // Already exists
  password: "AnotherPass1"
}

// Invalid: Malformed email
{
  email: "not-an-email",
  password: "ValidPass123"
}

// Invalid: Password too short
{
  email: "charlie@example.com",
  password: "short"
}

// Invalid: Missing required field
{
  email: "dave@example.com"
  // password missing
}
```

## Data Volume Estimates

**Current Story**:

- Expected users: 0-10 (development/testing only)
- Storage per user: ~500 bytes
- Total storage: Negligible

**Future Scale** (per constitutional NFR12):

- Expected users: 10,000+ (10x growth support)
- Storage per user: ~500 bytes
- Total storage: ~5 MB (users table only)
- Index overhead: ~1 MB

**Scalability**: User table design supports millions of users without modification. UUID primary keys enable horizontal sharding if needed in future.
